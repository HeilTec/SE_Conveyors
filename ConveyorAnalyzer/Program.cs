using Sandbox.Game.EntityComponents;
using Sandbox.ModAPI.Ingame;
using Sandbox.ModAPI.Interfaces;
using SpaceEngineers.Game.ModAPI.Ingame;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using VRage;
using VRage.Collections;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.GUI.TextPanel;
using VRage.Game.ModAPI.Ingame;
using VRage.Game.ModAPI.Ingame.Utilities;
using VRage.Game.ObjectBuilders.Definitions;
using VRageMath;

namespace IngameScript
{
    partial class Program : MyGridProgram
    {
        private const string SCRIPT_NAME = "Conveyor Analyzer";
        private const string SCRIPT_VERSION = "1.0";
        private const string LCD_TAG = "Conveyors LCD";
        private const string DEBUG_RUNTIME_TAG = "Runtime";

        private const string DEFAULT_HIGHLIGHT_COLOR = "FF4500";

        private const string INI_SECTION = "Conveyor";
        private const string INI_SECTION_DISPLAY = INI_SECTION + "_Display";
        private const string INI_KEY_DISPLAY = "display";
        private const string INI_KEY_COLOR = "color";
        private const string INI_KEY_SCALE = "scale";
        private const string INI_KEY_SKIP = "skip";
        private const string INI_KEY_SHOW_ALL = "show_all";
        private const string INI_KEY_VIA = "via";

        private readonly StringBuilder _sectionCandidateName = new StringBuilder();
        private readonly List<string> _sectionNames = new List<string>();
        private readonly MyIni _ini = new MyIni();
        private readonly List<DisplayCoordinator> _screens = new List<DisplayCoordinator>();
        private readonly List<IMyTerminalBlock> _providers = new List<IMyTerminalBlock>();
        private readonly List<IMyTextPanel> _taggedLCDs = new List<IMyTextPanel>();
        private readonly List<IMyTextPanel> _runtimeLCDs = new List<IMyTextPanel>();

        private readonly StringBuilder _outputText = new StringBuilder();
        internal readonly StringBuilder _echoText = new StringBuilder();
        internal readonly StringBuilder _runtimeStats = new StringBuilder();

        private readonly List<IMyTerminalBlock> _allInventoryBlocks = new List<IMyTerminalBlock>(64);
        private readonly List<IMyShipConnector> _allConnectors = new List<IMyShipConnector>(16);
        private readonly List<IMyShipConnector> _localConnectors = new List<IMyShipConnector>(8);
        private readonly List<Construct> _constructs = new List<Construct>(8);

        private static int _totalIslands = 0;
        private static int _totalSegments = 0;
        private static readonly MyItemType _largeItem = MyItemType.MakeComponent("LargeTube");
        bool HasLCDTag(IMyTerminalBlock TermBlock) =>
            TermBlock.CustomName.Contains(LCD_TAG);

        bool HasRuntimeTag(IMyTerminalBlock TermBlock) =>
            TermBlock.CustomName.Contains(DEBUG_RUNTIME_TAG);

        // Caches for List reuse. Separate Lists for each type to avoid extra enumerators generated by Queue.OfType<>
        private static readonly Queue _islandListQueue = new Queue(); // List<Island>
        private static readonly Queue _segmentListQueue = new Queue(); // List<Segment>
        private static readonly Queue _BlockListQueue = new Queue(); // List<IMyTerminaBlock>

        private IEnumerator<double> _mainSequenceSM = null;
        private string currentMainStep = "(Re)Compile";

        public Program()
        {
            Runtime.UpdateFrequency = UpdateFrequency.Update100;
            _runtimeStats.Append("Runtime Statistics:\n").Append(currentMainStep);
        }

        public void Main(string argument, UpdateType updateSource)
        {
            if ((updateSource & (UpdateType.Terminal | UpdateType.Trigger)) != 0)
                switch (argument.ToLowerInvariant())
                {
                    case "scan":
                        break;
                    case "reset":
                        _runtimeStats.Clear();
                        _runtimeStats.Append("Runtime Statistics:\n");
                        break;
                    default:
                        break;
                }
            if ((updateSource & UpdateType.Once) != 0)
            {
                Step();
                _runtimeStats.Append($"{Runtime.LastRunTimeMs}\n{currentMainStep} - ");
            }
            if ((updateSource & UpdateType.Update100) != 0)
            {
                if (_mainSequenceSM != null) return;
                _mainSequenceSM = MainSequence();
                Runtime.UpdateFrequency |= UpdateFrequency.Once;

                _runtimeStats.Append($"{Runtime.LastRunTimeMs}\n");
                foreach (var _runtimeLCD in _runtimeLCDs)
                {
                    _runtimeLCD.ContentType = ContentType.TEXT_AND_IMAGE;
                    _runtimeLCD.WriteText(_runtimeStats);
                }
                _runtimeStats.Append($"{updateSource} - ");
                Echo(_echoText.ToString());
            }
        }

        private IEnumerator<double> MainSequence()
        {
            yield return 1;

            currentMainStep = "Idle step";
            yield return 1;

            currentMainStep = "(Re)Start";
            var start = Runtime.CurrentInstructionCount;
            _echoText.Clear();
            _totalIslands = 0;
            _totalSegments = 0;
            _echoText.AppendLine($"{SCRIPT_NAME} {SCRIPT_VERSION}");
            yield return 1;

            currentMainStep = "CollectBlocks";
            CollectBlocks();
            _echoText.AppendLine($"{ Runtime.CurrentInstructionCount } instructions after CollectBlocks");
            _echoText.AppendLine($"{_allInventoryBlocks.Count} Inventory Blocks");
            yield return 1;

            currentMainStep = "FindConstructions";
            FindConstructions();
            _echoText.AppendLine($"{ Runtime.CurrentInstructionCount } instructions after FindConstructions");
            _echoText.AppendLine($"{_constructs.Count} Constructs");
            _echoText.AppendLine($"{_totalIslands} Islands");
            _echoText.AppendLine($"{_totalSegments} Segments");
            yield return 1;

            currentMainStep = "ParseScreensINI";
            ParseScreensINI();
            _echoText.AppendLine($"{ Runtime.CurrentInstructionCount } instructions after ParseScreensINI");
            _echoText.AppendLine($"{_screens.Count} Screens found");
            yield return 1;

            currentMainStep = "ShowConnectionsAsText";
            ShowConnectionsAsText();
            _echoText.AppendLine($"{ Runtime.CurrentInstructionCount } instructions after Text display");
            yield return 1;

            currentMainStep = "ShowConnectionsWithSprites";
            ShowConnectionsWithSprites();
            _echoText.AppendLine($"{ Runtime.CurrentInstructionCount } instructions after Sprite display");
            _echoText.AppendLine($"{ Runtime.MaxInstructionCount } Runtime.MaxInstructionCount");
            yield return 1;

            currentMainStep = "Main Sequence Done";
            yield return 1;

        }

        private void Step()
        {
            if (_mainSequenceSM != null)
            {
                try
                {
                    var moreSteps = _mainSequenceSM.MoveNext();
                    if (moreSteps)
                    {
                        Runtime.UpdateFrequency |= UpdateFrequency.Once;
                    }
                    else
                    {
                        _mainSequenceSM.Dispose();
                        _mainSequenceSM = null;
                    }
                }
                catch (Exception e)
                {
                    _runtimeStats.AppendLine($"*** Exception ***\n{e}");
                    //throw;
                }
            }
        }

        private void CollectBlocks()
        {
            _allInventoryBlocks.Clear();
            _localConnectors.Clear();
            _allConnectors.Clear();
            _providers.Clear();
            _taggedLCDs.Clear();
            _runtimeLCDs.Clear();

            GridTerminalSystem.GetBlocksOfType(_allInventoryBlocks, block =>
            {
                IMyShipConnector connector = block as IMyShipConnector;
                if (connector != null)
                {
                    _allConnectors.Add(connector);
                    if (block.IsSameConstructAs(Me))
                        _localConnectors.Add(connector);
                }

                IMyTextSurfaceProvider provider = block as IMyTextSurfaceProvider;
                if (provider != null &&
                    provider.SurfaceCount > 0 &&
                    block.IsSameConstructAs(Me) &&
                    block != Me)
                {
                    if (HasLCDTag(block))
                    {
                        _taggedLCDs.Add(block as IMyTextPanel);
                    }
                    else if (HasRuntimeTag(block))
                    {
                        _runtimeLCDs.Add(block as IMyTextPanel);
                    }
                    else _providers.Add(block);
                }
                return block.HasInventory;
            });
        }
        private void ParseScreensINI()
        {
            _screens.Clear();
            _providers.ForEach(displayBlock =>
            {
                if (displayBlock.Closed) return;
                if (!TryAddDiscreteScreens(displayBlock))
                {
                    TryAddScreen(displayBlock);
                }
            });
        }

        void AddScreen(IMyTextSurfaceProvider provider, int displayNumber, string section)
        {
            var display = provider.GetSurface(displayNumber);
            float scale = _ini.Get(section, INI_KEY_SCALE).ToSingle(0.5f);
            string colorStr = _ini.Get(section, INI_KEY_COLOR).ToString(DEFAULT_HIGHLIGHT_COLOR);
            if (colorStr.Length < 6)
                colorStr = DEFAULT_HIGHLIGHT_COLOR;
            Color color = new Color()
            {
                R = byte.Parse(colorStr.Substring(0, 2), System.Globalization.NumberStyles.HexNumber),
                G = byte.Parse(colorStr.Substring(2, 2), System.Globalization.NumberStyles.HexNumber),
                B = byte.Parse(colorStr.Substring(4, 2), System.Globalization.NumberStyles.HexNumber),
                A = 255
            };
            var linesToSkip = _ini.Get(section, INI_KEY_SKIP).ToInt16();
            bool showAll = _ini.Get(section, INI_KEY_SHOW_ALL).ToBoolean();
            string connectorName = _ini.Get(section, INI_KEY_VIA).ToString();
            IMyShipConnector viaConnector = null;
            if (connectorName != "")
            {
                viaConnector = _localConnectors.Find(con => con.DisplayNameText.Contains(connectorName));
                if (viaConnector == null) _echoText.AppendLine($"** WARNING ** '{connectorName}' not found. Full list displayed.");
            }

            _screens.Add(new DisplayCoordinator(
                display, scale, color, linesToSkip, showAll, viaConnector));
        }

        private bool TryAddDiscreteScreens(IMyTerminalBlock block)
        {
            bool retval = false;
            IMyTextSurfaceProvider provider = block as IMyTextSurfaceProvider;
            if (null == provider || provider.SurfaceCount == 0)
                return true;
            StringComparison ignoreCase = StringComparison.InvariantCultureIgnoreCase;
            bool success = _ini.TryParse(block.CustomData);
            if (!success)
            {
                _echoText.AppendLine($"Warning: Failed to parse custom data in {block.DisplayNameText}");
                return true;
            }
            _ini.GetSections(_sectionNames);
            foreach (var section in _sectionNames)
            {
                if (section.StartsWith(INI_SECTION_DISPLAY, ignoreCase))
                {
                    for (int displayNumber = 0; displayNumber < provider.SurfaceCount; ++displayNumber)
                    {
                        _sectionCandidateName.Clear();
                        _sectionCandidateName.Append(INI_SECTION_DISPLAY).Append(displayNumber.ToString());
                        if (section.Equals(_sectionCandidateName.ToString(), ignoreCase))
                        {
                            AddScreen(provider, displayNumber, section);
                            retval = true;
                        }
                    }
                }
            }
            return retval;
        }

        private void TryAddScreen(IMyTerminalBlock block)
        {
            IMyTextSurfaceProvider provider = block as IMyTextSurfaceProvider;
            if (null == provider || provider.SurfaceCount == 0 || !MyIni.HasSection(block.CustomData, INI_SECTION))
                return;
            bool success = _ini.TryParse(block.CustomData);
            if (!success)
            {
                _echoText.AppendLine($"Warning: Failed to parse custom data in {block.DisplayNameText}");
                return;
            }
            var displayNumber = _ini.Get(INI_SECTION, INI_KEY_DISPLAY).ToUInt16();
            if (displayNumber < provider.SurfaceCount)
            {
                AddScreen(provider, displayNumber, INI_SECTION);
            }
            else
            {
                _echoText.AppendLine($"Warning: {block.CustomName} doesn't have a display number {_ini.Get(INI_SECTION, INI_KEY_DISPLAY)}");
            }
        }


        internal class Construct
        {
            public readonly IMyTerminalBlock referenceBlock;
            public List<Island> Islands { get; private set; }
            public Construct(IMyTerminalBlock newBlock)
            {
                referenceBlock = newBlock;
                if (_islandListQueue.Count > 0)
                {
                    var newList = _islandListQueue.Dequeue() as List<Island>;
                    if (newList != null) Islands = newList;
                }
                if (Islands == null) Islands = new List<Island>();
                Islands.Add(new Island(new Segment(newBlock)));
            }
            public bool IsSameConstructAs(IMyTerminalBlock block)
            {
                return !referenceBlock.Closed && referenceBlock.IsSameConstructAs(block);
            }
            public void AddBlock(IMyTerminalBlock newBlock)
            {
                bool found = false;
                foreach (var island in Islands)
                {
                    if (island.IsSameIslandAs(newBlock))
                    {
                        island.AddBlock(newBlock);
                        found = true;
                        break;
                    }
                }
                if (!found) Islands.Add(new Island(new Segment(newBlock)));
            }
            public void Clear()
            {
                foreach (var island in Islands)
                {
                    island.Clear();
                }
                Islands.Clear();
                _islandListQueue.Enqueue(Islands);
                Islands = null;
            }
        }

        internal class Island
        {
            public IMyTerminalBlock referenceBlock;
            public List<Segment> Segments { get; private set; } = null;
            public Island(Segment newSegment)
            {
                referenceBlock = newSegment.Blocks[0];
                if (_segmentListQueue.Count > 0)
                {
                    var newList = _segmentListQueue.Dequeue() as List<Segment>;
                    if (newList != null) Segments = newList;
                }
                if (Segments == null) Segments = new List<Segment>();
                Segments.Add(newSegment);
                _totalIslands++;
            }
            public bool IsSameIslandAs(IMyTerminalBlock block)
            {
                //if(referenceBlock.Closed)
                //{
                //    var found = false;
                //    foreach (var segment in Segments)
                //    {
                //        foreach (var b in segment.Blocks)
                //        {
                //            if (!b.Closed)
                //            {
                //                found = true;
                //                referenceBlock = b;
                //                break;
                //            }
                //        }
                //        if (found) break;
                //    }
                //}
                return !referenceBlock.Closed && referenceBlock.GetInventory().IsConnectedTo(block.GetInventory());
            }
            public void AddBlock(IMyTerminalBlock newBlock)
            {
                bool found = false;
                foreach (var segment in Segments)
                {
                    if (segment.SameSegment(newBlock))
                    {
                        segment.Blocks.Add(newBlock);
                        found = true;
                        break;
                    }
                }
                if (!found) Segments.Add(new Segment(newBlock));
            }
            public void Clear()
            {
                foreach (var segment in Segments)
                {
                    segment.Clear();
                }
                Segments.Clear();
                _segmentListQueue.Enqueue(Segments);
                Segments = null;
                _totalIslands--;
            }
        }

        internal class Segment
        {
            public List<IMyTerminalBlock> Blocks { get; private set; } = null;
            public Segment(IMyTerminalBlock newBlock)
            {
                if (_BlockListQueue.Count > 0)
                {
                    List<IMyTerminalBlock> newList = _BlockListQueue.Dequeue() as List<IMyTerminalBlock>;
                    if (newList != null)
                        Blocks = newList;
                }
                if (Blocks == null)
                    Blocks = new List<IMyTerminalBlock>();
                Blocks.Add(newBlock);
                _totalSegments++;
            }
            public bool SameSegment(IMyTerminalBlock block)
            {
                return !Blocks[0].Closed && Blocks[0].GetInventory().CanTransferItemTo(block.GetInventory(), _largeItem);
            }
            public void Clear()
            {
                Blocks.Clear();
                _BlockListQueue.Enqueue(Blocks);
                Blocks = null;
                _totalSegments--;
            }
        }

        /// <summary>
        /// constructs filled with all blocks from each construct
        /// </summary>
        private void FindConstructions()
        {
            _constructs.Clear();

            foreach (var block in _allInventoryBlocks)
            {
                if (!block.Closed)
                {
                    var found = false;
                    foreach (var construct in _constructs)
                    {
                        if (construct.IsSameConstructAs(block))
                        {
                            construct.AddBlock(block);
                            found = true;
                            break;
                        }
                    }
                    if (!found) _constructs.Add(new Construct(block));
                }
            }
        }

        private void ShowConnectionsAsText()
        {
            if (_taggedLCDs.Count == 0) return;
            _outputText.Clear();
            _outputText.Append("List of constructions:\n---------------------\n");
            _outputText.AppendLine();

            foreach (var construct in _constructs)
            {
                _outputText.Append("Grid: ");
                IMyCubeGrid thisGrid = construct.Islands[0].Segments[0].Blocks[0].CubeGrid;
                _outputText.AppendLine(thisGrid.DisplayName);
                MyCubeSize gridSize = thisGrid.GridSizeEnum;
                foreach (var island in construct.Islands)
                {
                    foreach (var segment in island.Segments)
                    {
                        foreach (var block in segment.Blocks)
                        {
                            _outputText.Append("    ||  ");
                            _outputText.AppendLine(block.DisplayNameText);

                        }
                        _outputText.AppendLine("     |  ");
                    }
                    _outputText.AppendLine();
                }
                _outputText.AppendLine();
            }

            foreach (IMyTextPanel LCD in _taggedLCDs)
            {
                LCD.ContentType = ContentType.TEXT_AND_IMAGE;
                LCD.WriteText(_outputText);
            }
        }

        private void ShowConnectionsWithSprites()
        {
            foreach (DisplayCoordinator display in _screens)
            {
                display.Render(_constructs);
            }
        }
    }
}
